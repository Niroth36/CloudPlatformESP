/*
 * Copyright 2018 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = function(RED) {

    var container = require('rhea');

    function generateRandomString(length) {
        const characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let result = '';
      
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * characters.length));
        }
        return result;
    }

    /**
     * Node for configuring an AMQP endpoint
     */
    function amqpEndpointNode(n) {

        RED.nodes.createNode(this, n);

        // save node parameters
        this.host = n.host;
        this.port = n.port;

        if (this.host == '') {
            this.host = '127.0.0.1';
        }
        if (this.port == '') {
            this.port = 5672;
        }

        // build options for connection
        var options = { host: this.host, port: this.port};
        options.container_id = "node-red-rhea-" + container.generate_uuid();

        var node = this;

        this.connected = false;
        this.connecting = false;
        
        /**
         * Exposed function for connecting to the remote AMQP container
         * creating an AMQP connection object
         *
         * @param callback  function called when the connection is established
         */
        this.connect = function(callback) {

            // AMQP connection not established, trying to do that
            if (!node.connected && !node.connecting) {

                node.connecting = true;
                node.connection = container.connect(options);

                node.connection.on('connection_error', function(context) {

                    node.connecting = false;
                    node.connected = false;
                    var error = context.connection.get_error();
                    node.error(error);

                });

                node.connection.on('connection_open', function(context) {

                    node.connecting = false;
                    node.connected = true;

                    callback(context.connection);
                });

                node.connection.on('disconnected', function(context) {

                    node.connected = false;
                });

            // AMQP connection already established
            } else {

                callback(node.connection);
            }

        }
    }

    RED.nodes.registerType('amqp-endpoint', amqpEndpointNode)

    /**
     * Node for AMQP sender
     */
    function amqpSenderNode(config) {

        RED.nodes.createNode(this, config);

        // get endpoint configuration
        this.endpoint = RED.nodes.getNode(config.endpoint);
        // get all other configuration
        this.host = this.endpoint.host;
        this.port = this.endpoint.port;
        this.address = config.address;

        if (this.address == '') {
            this.address = "e2c_n";
        }

        var node = this;
        var total_sent = 0;
    
        node.on('input', function(msg) {
            var sent = 0;

            var sender = container.connect({port: node.port, host: node.host, container_id: container.generate_uuid()}).open_sender(node.address);

            sender.once('sendable', function (context) {
                sent++;
                context.sender.send(msg.payload);
                total_sent++;
                var status = 'send:' + total_sent;
                node.status({ fill: 'green', shape: 'dot', text: status });
            });
            sender.once('accepted', function (context) {
                context.connection.close();
            });
        });
    }

    RED.nodes.registerType('amqp-sender', amqpSenderNode);

    /**
     * Node for AMQP receiver
     */
    function amqpReceiverNode(config) {

        RED.nodes.createNode(this, config);

        // get endpoint configuration
        this.endpoint = RED.nodes.getNode(config.endpoint);
        // get all other configuration
        this.address = config.address;
        this.autoaccept = true;
        this.creditwindow = 5;
        this.dynamic = false;
        this.sndsettlemode = 2;     //"mixed"
        this.rcvsettlemode = 0;     //"first"
        this.durable = 0;           //"none"
        this.expirypolicy = 'session-end';

        var node = this;
        // node not yet connected
        this.status({ fill: 'red', shape: 'dot', text: 'disconnected' });

        if (this.endpoint) {

            node.endpoint.connect(function(connection) {
                setup(connection);
            });

            /**
             * Node setup for creating receiver link
             *
             * @param connection    Connection instance
             */
            function setup(connection) {

                node.connection = connection;

                // node connected
                node.status({ fill: 'green', shape: 'dot', text: 'connected' });

                // build receiver options based on node configuration
                var options = {
                    source: {
                        address: node.address,
                        dynamic: node.dynamic,
                        durable: node.durable,
                        expiry_policy: node.expirypolicy
                     },
                    credit_window: node.creditwindow,
                    autoaccept: node.autoaccept,
                    snd_settle_mode: node.sndsettlemode,
                    rcv_settle_mode: node.rcvsettlemode
                };

                node.receiver = node.connection.open_receiver(options);

                node.receiver.on('message', function(context) {
                    var msg = {
                        payload: context.message,
                        delivery: context.delivery
                    };
                    node.send(msg);
                });

                node.connection.on('disconnected', function(context) {
                    // node disconnected
                    node.status({fill: 'red', shape: 'dot', text: 'disconnected' });
                });

                node.on('input', function(msg) {
                    if (msg.credit) {
                        node.receiver.flow(msg.credit);
                    }
                });

                node.on('close', function() {
                    if (node.receiver != null)
                        node.receiver.detach();
                    node.connection.close();
                });
            }

        }
    }

    RED.nodes.registerType('amqp-receiver', amqpReceiverNode)

    function formatDataReport(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        node.on('input', function(msg) {
            var data = msg.payload;
            var message = {};
            message.cmd = "s2n_data_report";
            message.from = "e2c_s_nodered";
            message.to = "e2c_n";
            message.data = {};
            message.data.dataId = generateRandomString(10);
            message.data.payload = [];

            var payload = {};
            payload.subProtocol = "nodered";
            payload.subDeviceId = "";
            payload.subDeviceTag = "";
            payload.param = data;
            payload.param.timestamp = Math.floor(new Date().getTime() / 1000);
            message.data.payload.push(payload);

            var output = {};
            output.payload = {};
            output.payload.body = JSON.stringify(message);
            node.send(output);
        });
    }
    RED.nodes.registerType("data-report", formatDataReport);
    
    function formatControlReq(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        node.on('input', function(msg) {
            var data = msg.payload;
            var message = {};
            message.cmd = "n2s_control_req";
            message.from = "e2c_s_nodered";
            message.to = "e2c_s_" + config.protocol;
            message.data = {};
            message.data.dataId = generateRandomString(10);

            var payload = {};
            payload.subProtocol = config.protocol;
            payload.subDeviceId = config.device_id;
            payload.subDeviceTag = config.device_tag;
            payload.cmdType = config.cmd_type;
            if (payload.cmdType == "") {
                payload.cmdType = "writeReg";
            }
            payload.param = data;
            message.data.payload = payload;

            var output = {};
            output.payload = {};
            output.payload.body = JSON.stringify(message);
            node.send(output);
        });
    }
    RED.nodes.registerType("control-request", formatControlReq);
}
